// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "messages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message BatteryCellInfo
 */
export interface BatteryCellInfo {
    /**
     * @generated from protobuf field: bool under_voltage = 1;
     */
    underVoltage: boolean;
    /**
     * @generated from protobuf field: bool over_voltage = 2;
     */
    overVoltage: boolean;
    /**
     * @generated from protobuf field: bool balance = 3;
     */
    balance: boolean;
    /**
     * @generated from protobuf field: float value = 4;
     */
    value: number;
}
/**
 * @generated from protobuf message BatteryInfo
 */
export interface BatteryInfo {
    /**
     * @generated from protobuf field: repeated BatteryCellInfo cells = 1;
     */
    cells: BatteryCellInfo[];
    /**
     * @generated from protobuf field: float current = 2;
     */
    current: number;
    /**
     * @generated from protobuf field: float soc = 3;
     */
    soc: number;
    /**
     * @generated from protobuf field: float full_capacity = 4;
     */
    fullCapacity: number;
    /**
     * @generated from protobuf field: repeated sint32 temperatures = 5;
     */
    temperatures: number[];
    /**
     * @generated from protobuf field: bytes alarm = 6;
     */
    alarm: Uint8Array;
    /**
     * @generated from protobuf field: int32 loop = 7;
     */
    loop: number;
    /**
     * @generated from protobuf field: float voltage_sum = 8;
     */
    voltageSum: number;
    /**
     * @generated from protobuf field: float soh = 9;
     */
    soh: number;
}
/**
 * @generated from protobuf message RectifierInfo
 */
export interface RectifierInfo {
    /**
     * @generated from protobuf field: uint32 status_value = 1;
     */
    statusValue: number;
    /**
     * @generated from protobuf field: float input_power = 2;
     */
    inputPower: number;
    /**
     * @generated from protobuf field: float input_frequency = 3;
     */
    inputFrequency: number;
    /**
     * @generated from protobuf field: float input_current = 4;
     */
    inputCurrent: number;
    /**
     * @generated from protobuf field: float output_power = 5;
     */
    outputPower: number;
    /**
     * @generated from protobuf field: float efficiency = 6;
     */
    efficiency: number;
    /**
     * @generated from protobuf field: float output_voltage = 7;
     */
    outputVoltage: number;
    /**
     * @generated from protobuf field: float max_output_current = 8;
     */
    maxOutputCurrent: number;
    /**
     * @generated from protobuf field: float input_voltage = 9;
     */
    inputVoltage: number;
    /**
     * @generated from protobuf field: float output_module_temp = 10;
     */
    outputModuleTemp: number;
    /**
     * @generated from protobuf field: float input_module_temp = 11;
     */
    inputModuleTemp: number;
    /**
     * @generated from protobuf field: float output_current = 12;
     */
    outputCurrent: number;
    /**
     * @generated from protobuf field: uint32 alarm_value = 13;
     */
    alarmValue: number;
}
/**
 * @generated from protobuf message StaticIpConfig
 */
export interface StaticIpConfig {
    /**
     * @generated from protobuf field: bytes addr = 1;
     */
    addr: Uint8Array;
    /**
     * @generated from protobuf field: bytes netmask = 2;
     */
    netmask: Uint8Array;
    /**
     * @generated from protobuf field: bytes gateway = 3;
     */
    gateway: Uint8Array;
    /**
     * @generated from protobuf field: bytes dns_server = 4;
     */
    dnsServer: Uint8Array;
}
/**
 * @generated from protobuf message DhcpConfig
 */
export interface DhcpConfig {
    /**
     * @generated from protobuf field: string hostname = 1;
     */
    hostname: string;
}
/**
 * @generated from protobuf message Parameters
 */
export interface Parameters {
    /**
     * @generated from protobuf field: float charge_current_0_5 = 1;
     */
    chargeCurrent05: number;
    /**
     * @generated from protobuf field: float charge_current_5_90 = 2;
     */
    chargeCurrent590: number;
    /**
     * @generated from protobuf field: float charge_current_90_100 = 3;
     */
    chargeCurrent90100: number;
    /**
     * @generated from protobuf field: float safe_voltage = 4;
     */
    safeVoltage: number;
    /**
     * Battery low level: when battery SoC is lower than this threshold,
     * mains_supply_enable will be ignored, and mains will always be enabled
     *
     * @generated from protobuf field: float battery_low = 5;
     */
    batteryLow: number;
    /**
     * Battery critical level: when battery SoC is lower than this threshold,
     * notify all computers with NUT protocol shutdown
     *
     * @generated from protobuf field: float battery_critical = 6;
     */
    batteryCritical: number;
}
/**
 * @generated from protobuf message NetworkConfig
 */
export interface NetworkConfig {
    /**
     * @generated from protobuf field: repeated string ntp_server = 1;
     */
    ntpServer: string[];
    /**
     * @generated from protobuf field: StaticIpConfig static_ip = 2;
     */
    staticIp?: StaticIpConfig;
    /**
     * If dhcp not working, fall back to static ip
     *
     * @generated from protobuf field: optional DhcpConfig dhcp = 3;
     */
    dhcp?: DhcpConfig;
}
/**
 * @generated from protobuf message PowerConfig
 */
export interface PowerConfig {
    /**
     * @generated from protobuf field: Parameters params = 1;
     */
    params?: Parameters;
    /**
     * @generated from protobuf field: bool charge_disable = 2;
     */
    chargeDisable: boolean;
    /**
     * @generated from protobuf field: bool mains_supply_disable = 3;
     */
    mainsSupplyDisable: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class BatteryCellInfo$Type extends MessageType<BatteryCellInfo> {
    constructor() {
        super("BatteryCellInfo", [
            { no: 1, name: "under_voltage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "over_voltage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "balance", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BatteryCellInfo>): BatteryCellInfo {
        const message = { underVoltage: false, overVoltage: false, balance: false, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatteryCellInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatteryCellInfo): BatteryCellInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool under_voltage */ 1:
                    message.underVoltage = reader.bool();
                    break;
                case /* bool over_voltage */ 2:
                    message.overVoltage = reader.bool();
                    break;
                case /* bool balance */ 3:
                    message.balance = reader.bool();
                    break;
                case /* float value */ 4:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatteryCellInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool under_voltage = 1; */
        if (message.underVoltage !== false)
            writer.tag(1, WireType.Varint).bool(message.underVoltage);
        /* bool over_voltage = 2; */
        if (message.overVoltage !== false)
            writer.tag(2, WireType.Varint).bool(message.overVoltage);
        /* bool balance = 3; */
        if (message.balance !== false)
            writer.tag(3, WireType.Varint).bool(message.balance);
        /* float value = 4; */
        if (message.value !== 0)
            writer.tag(4, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BatteryCellInfo
 */
export const BatteryCellInfo = new BatteryCellInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatteryInfo$Type extends MessageType<BatteryInfo> {
    constructor() {
        super("BatteryInfo", [
            { no: 1, name: "cells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BatteryCellInfo, options: { nanopb: { maxCount: 16 } } },
            { no: 2, name: "current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "soc", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "full_capacity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "temperatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/, options: { nanopb: { maxCount: 4 } } },
            { no: 6, name: "alarm", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { nanopb: { maxSize: 12 } } },
            { no: 7, name: "loop", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "voltage_sum", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "soh", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BatteryInfo>): BatteryInfo {
        const message = { cells: [], current: 0, soc: 0, fullCapacity: 0, temperatures: [], alarm: new Uint8Array(0), loop: 0, voltageSum: 0, soh: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatteryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatteryInfo): BatteryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BatteryCellInfo cells */ 1:
                    message.cells.push(BatteryCellInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* float current */ 2:
                    message.current = reader.float();
                    break;
                case /* float soc */ 3:
                    message.soc = reader.float();
                    break;
                case /* float full_capacity */ 4:
                    message.fullCapacity = reader.float();
                    break;
                case /* repeated sint32 temperatures */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temperatures.push(reader.sint32());
                    else
                        message.temperatures.push(reader.sint32());
                    break;
                case /* bytes alarm */ 6:
                    message.alarm = reader.bytes();
                    break;
                case /* int32 loop */ 7:
                    message.loop = reader.int32();
                    break;
                case /* float voltage_sum */ 8:
                    message.voltageSum = reader.float();
                    break;
                case /* float soh */ 9:
                    message.soh = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatteryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BatteryCellInfo cells = 1; */
        for (let i = 0; i < message.cells.length; i++)
            BatteryCellInfo.internalBinaryWrite(message.cells[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float current = 2; */
        if (message.current !== 0)
            writer.tag(2, WireType.Bit32).float(message.current);
        /* float soc = 3; */
        if (message.soc !== 0)
            writer.tag(3, WireType.Bit32).float(message.soc);
        /* float full_capacity = 4; */
        if (message.fullCapacity !== 0)
            writer.tag(4, WireType.Bit32).float(message.fullCapacity);
        /* repeated sint32 temperatures = 5; */
        for (let i = 0; i < message.temperatures.length; i++)
            writer.tag(5, WireType.Varint).sint32(message.temperatures[i]);
        /* bytes alarm = 6; */
        if (message.alarm.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.alarm);
        /* int32 loop = 7; */
        if (message.loop !== 0)
            writer.tag(7, WireType.Varint).int32(message.loop);
        /* float voltage_sum = 8; */
        if (message.voltageSum !== 0)
            writer.tag(8, WireType.Bit32).float(message.voltageSum);
        /* float soh = 9; */
        if (message.soh !== 0)
            writer.tag(9, WireType.Bit32).float(message.soh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BatteryInfo
 */
export const BatteryInfo = new BatteryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RectifierInfo$Type extends MessageType<RectifierInfo> {
    constructor() {
        super("RectifierInfo", [
            { no: 1, name: "status_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "input_power", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "input_frequency", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "input_current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "output_power", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "efficiency", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "output_voltage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "max_output_current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "input_voltage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "output_module_temp", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "input_module_temp", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "output_current", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "alarm_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RectifierInfo>): RectifierInfo {
        const message = { statusValue: 0, inputPower: 0, inputFrequency: 0, inputCurrent: 0, outputPower: 0, efficiency: 0, outputVoltage: 0, maxOutputCurrent: 0, inputVoltage: 0, outputModuleTemp: 0, inputModuleTemp: 0, outputCurrent: 0, alarmValue: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RectifierInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RectifierInfo): RectifierInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status_value */ 1:
                    message.statusValue = reader.uint32();
                    break;
                case /* float input_power */ 2:
                    message.inputPower = reader.float();
                    break;
                case /* float input_frequency */ 3:
                    message.inputFrequency = reader.float();
                    break;
                case /* float input_current */ 4:
                    message.inputCurrent = reader.float();
                    break;
                case /* float output_power */ 5:
                    message.outputPower = reader.float();
                    break;
                case /* float efficiency */ 6:
                    message.efficiency = reader.float();
                    break;
                case /* float output_voltage */ 7:
                    message.outputVoltage = reader.float();
                    break;
                case /* float max_output_current */ 8:
                    message.maxOutputCurrent = reader.float();
                    break;
                case /* float input_voltage */ 9:
                    message.inputVoltage = reader.float();
                    break;
                case /* float output_module_temp */ 10:
                    message.outputModuleTemp = reader.float();
                    break;
                case /* float input_module_temp */ 11:
                    message.inputModuleTemp = reader.float();
                    break;
                case /* float output_current */ 12:
                    message.outputCurrent = reader.float();
                    break;
                case /* uint32 alarm_value */ 13:
                    message.alarmValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RectifierInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status_value = 1; */
        if (message.statusValue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.statusValue);
        /* float input_power = 2; */
        if (message.inputPower !== 0)
            writer.tag(2, WireType.Bit32).float(message.inputPower);
        /* float input_frequency = 3; */
        if (message.inputFrequency !== 0)
            writer.tag(3, WireType.Bit32).float(message.inputFrequency);
        /* float input_current = 4; */
        if (message.inputCurrent !== 0)
            writer.tag(4, WireType.Bit32).float(message.inputCurrent);
        /* float output_power = 5; */
        if (message.outputPower !== 0)
            writer.tag(5, WireType.Bit32).float(message.outputPower);
        /* float efficiency = 6; */
        if (message.efficiency !== 0)
            writer.tag(6, WireType.Bit32).float(message.efficiency);
        /* float output_voltage = 7; */
        if (message.outputVoltage !== 0)
            writer.tag(7, WireType.Bit32).float(message.outputVoltage);
        /* float max_output_current = 8; */
        if (message.maxOutputCurrent !== 0)
            writer.tag(8, WireType.Bit32).float(message.maxOutputCurrent);
        /* float input_voltage = 9; */
        if (message.inputVoltage !== 0)
            writer.tag(9, WireType.Bit32).float(message.inputVoltage);
        /* float output_module_temp = 10; */
        if (message.outputModuleTemp !== 0)
            writer.tag(10, WireType.Bit32).float(message.outputModuleTemp);
        /* float input_module_temp = 11; */
        if (message.inputModuleTemp !== 0)
            writer.tag(11, WireType.Bit32).float(message.inputModuleTemp);
        /* float output_current = 12; */
        if (message.outputCurrent !== 0)
            writer.tag(12, WireType.Bit32).float(message.outputCurrent);
        /* uint32 alarm_value = 13; */
        if (message.alarmValue !== 0)
            writer.tag(13, WireType.Varint).uint32(message.alarmValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RectifierInfo
 */
export const RectifierInfo = new RectifierInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticIpConfig$Type extends MessageType<StaticIpConfig> {
    constructor() {
        super("StaticIpConfig", [
            { no: 1, name: "addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { nanopb: { maxSize: 4, fixedLength: true } } },
            { no: 2, name: "netmask", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { nanopb: { maxSize: 4, fixedLength: true } } },
            { no: 3, name: "gateway", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { nanopb: { maxSize: 4, fixedLength: true } } },
            { no: 4, name: "dns_server", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { nanopb: { maxSize: 4, fixedLength: true } } }
        ]);
    }
    create(value?: PartialMessage<StaticIpConfig>): StaticIpConfig {
        const message = { addr: new Uint8Array(0), netmask: new Uint8Array(0), gateway: new Uint8Array(0), dnsServer: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StaticIpConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticIpConfig): StaticIpConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes addr */ 1:
                    message.addr = reader.bytes();
                    break;
                case /* bytes netmask */ 2:
                    message.netmask = reader.bytes();
                    break;
                case /* bytes gateway */ 3:
                    message.gateway = reader.bytes();
                    break;
                case /* bytes dns_server */ 4:
                    message.dnsServer = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticIpConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes addr = 1; */
        if (message.addr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.addr);
        /* bytes netmask = 2; */
        if (message.netmask.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.netmask);
        /* bytes gateway = 3; */
        if (message.gateway.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.gateway);
        /* bytes dns_server = 4; */
        if (message.dnsServer.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.dnsServer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StaticIpConfig
 */
export const StaticIpConfig = new StaticIpConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DhcpConfig$Type extends MessageType<DhcpConfig> {
    constructor() {
        super("DhcpConfig", [
            { no: 1, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { nanopb: { maxLength: 12 } } }
        ]);
    }
    create(value?: PartialMessage<DhcpConfig>): DhcpConfig {
        const message = { hostname: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DhcpConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DhcpConfig): DhcpConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DhcpConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hostname = 1; */
        if (message.hostname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DhcpConfig
 */
export const DhcpConfig = new DhcpConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Parameters$Type extends MessageType<Parameters> {
    constructor() {
        super("Parameters", [
            { no: 1, name: "charge_current_0_5", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "charge_current_5_90", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "charge_current_90_100", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "safe_voltage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "battery_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "battery_critical", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Parameters>): Parameters {
        const message = { chargeCurrent05: 0, chargeCurrent590: 0, chargeCurrent90100: 0, safeVoltage: 0, batteryLow: 0, batteryCritical: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Parameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Parameters): Parameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float charge_current_0_5 */ 1:
                    message.chargeCurrent05 = reader.float();
                    break;
                case /* float charge_current_5_90 */ 2:
                    message.chargeCurrent590 = reader.float();
                    break;
                case /* float charge_current_90_100 */ 3:
                    message.chargeCurrent90100 = reader.float();
                    break;
                case /* float safe_voltage */ 4:
                    message.safeVoltage = reader.float();
                    break;
                case /* float battery_low */ 5:
                    message.batteryLow = reader.float();
                    break;
                case /* float battery_critical */ 6:
                    message.batteryCritical = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Parameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float charge_current_0_5 = 1; */
        if (message.chargeCurrent05 !== 0)
            writer.tag(1, WireType.Bit32).float(message.chargeCurrent05);
        /* float charge_current_5_90 = 2; */
        if (message.chargeCurrent590 !== 0)
            writer.tag(2, WireType.Bit32).float(message.chargeCurrent590);
        /* float charge_current_90_100 = 3; */
        if (message.chargeCurrent90100 !== 0)
            writer.tag(3, WireType.Bit32).float(message.chargeCurrent90100);
        /* float safe_voltage = 4; */
        if (message.safeVoltage !== 0)
            writer.tag(4, WireType.Bit32).float(message.safeVoltage);
        /* float battery_low = 5; */
        if (message.batteryLow !== 0)
            writer.tag(5, WireType.Bit32).float(message.batteryLow);
        /* float battery_critical = 6; */
        if (message.batteryCritical !== 0)
            writer.tag(6, WireType.Bit32).float(message.batteryCritical);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Parameters
 */
export const Parameters = new Parameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkConfig$Type extends MessageType<NetworkConfig> {
    constructor() {
        super("NetworkConfig", [
            { no: 1, name: "ntp_server", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { nanopb: { maxLength: 20, maxCount: 3 } } },
            { no: 2, name: "static_ip", kind: "message", T: () => StaticIpConfig },
            { no: 3, name: "dhcp", kind: "message", T: () => DhcpConfig }
        ]);
    }
    create(value?: PartialMessage<NetworkConfig>): NetworkConfig {
        const message = { ntpServer: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetworkConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkConfig): NetworkConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ntp_server */ 1:
                    message.ntpServer.push(reader.string());
                    break;
                case /* StaticIpConfig static_ip */ 2:
                    message.staticIp = StaticIpConfig.internalBinaryRead(reader, reader.uint32(), options, message.staticIp);
                    break;
                case /* optional DhcpConfig dhcp */ 3:
                    message.dhcp = DhcpConfig.internalBinaryRead(reader, reader.uint32(), options, message.dhcp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ntp_server = 1; */
        for (let i = 0; i < message.ntpServer.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ntpServer[i]);
        /* StaticIpConfig static_ip = 2; */
        if (message.staticIp)
            StaticIpConfig.internalBinaryWrite(message.staticIp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional DhcpConfig dhcp = 3; */
        if (message.dhcp)
            DhcpConfig.internalBinaryWrite(message.dhcp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NetworkConfig
 */
export const NetworkConfig = new NetworkConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PowerConfig$Type extends MessageType<PowerConfig> {
    constructor() {
        super("PowerConfig", [
            { no: 1, name: "params", kind: "message", T: () => Parameters },
            { no: 2, name: "charge_disable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mains_supply_disable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PowerConfig>): PowerConfig {
        const message = { chargeDisable: false, mainsSupplyDisable: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PowerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PowerConfig): PowerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Parameters params */ 1:
                    message.params = Parameters.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* bool charge_disable */ 2:
                    message.chargeDisable = reader.bool();
                    break;
                case /* bool mains_supply_disable */ 3:
                    message.mainsSupplyDisable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PowerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Parameters params = 1; */
        if (message.params)
            Parameters.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool charge_disable = 2; */
        if (message.chargeDisable !== false)
            writer.tag(2, WireType.Varint).bool(message.chargeDisable);
        /* bool mains_supply_disable = 3; */
        if (message.mainsSupplyDisable !== false)
            writer.tag(3, WireType.Varint).bool(message.mainsSupplyDisable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PowerConfig
 */
export const PowerConfig = new PowerConfig$Type();
